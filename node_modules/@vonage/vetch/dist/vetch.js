"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vetch = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const querystring_1 = require("querystring");
const lodash_merge_1 = tslib_1.__importDefault(require("lodash.merge"));
const http_1 = tslib_1.__importDefault(require("http"));
const https_1 = tslib_1.__importDefault(require("https"));
const types_1 = require("./types");
class Vetch {
    constructor(defaults) {
        this.defaults = defaults || { responseType: types_1.ResponseTypes.json };
        if (!this.defaults.responseType) {
            this.defaults.responseType = types_1.ResponseTypes.json;
        }
    }
    _defaultAdapter(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const res = yield (0, node_fetch_1.default)(opts.url, opts);
            const data = yield this.getResponseData(opts, res);
            return this.createResponse(opts, res, data);
        });
    }
    request(opts = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            opts = this.validateOpts(opts);
            try {
                let formattedResponse;
                formattedResponse = yield this._defaultAdapter(opts);
                if (!opts.checkStatus(formattedResponse.status)) {
                    const err = new types_1.VetchError(`Request failed with status code ${formattedResponse.status}`, opts);
                    err.code = String(formattedResponse.status);
                    err.response = formattedResponse;
                    throw err;
                }
                return formattedResponse;
            }
            catch (e) {
                throw e;
            }
        });
    }
    getResponseData(opts, res) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (opts.responseType) {
                case 'json': {
                    let data = yield res.text();
                    try {
                        data = JSON.parse(data);
                    }
                    catch (_a) {
                    }
                    return data;
                }
                default:
                    return res.text();
            }
        });
    }
    validateOpts(options) {
        const opts = (0, lodash_merge_1.default)({}, this.defaults, options);
        opts.headers = opts.headers || {};
        opts.checkStatus = this.checkStatus;
        opts.responseType = opts.responseType;
        if (!opts.url) {
            throw new Error('URL is required.');
        }
        const baseUrl = opts.baseUrl || opts.baseURL;
        if (baseUrl) {
            opts.url = baseUrl + opts.url;
        }
        if (opts.params) {
            let queryParams = (0, querystring_1.stringify)(opts.params);
            if (queryParams.startsWith('?')) {
                queryParams = queryParams.slice(1);
            }
            const prefix = opts.url.includes('?') ? '&' : '?';
            opts.url = `${opts.url}${prefix}${queryParams}`;
        }
        if (opts.data) {
            if (typeof opts.data === 'object') {
                opts.body = JSON.stringify(opts.data);
                opts.headers['Content-Type'] = 'application/json';
            }
            else {
                opts.body = opts.data;
            }
        }
        if (!opts.headers.Accept && opts.responseType === 'json') {
            opts.headers.Accept = 'application/json';
        }
        opts.headers['user-agent'] = `@vonage/server-sdk/3.0.0 node/${process.version.replace('v', '')}`;
        const httpAgent = new http_1.default.Agent({
            timeout: this.defaults.timeout,
        });
        const httpsAgent = new https_1.default.Agent({
            timeout: this.defaults.timeout,
        });
        opts.agent = (parsedUrl) => {
            if (parsedUrl.protocol === 'http:') {
                return httpAgent;
            }
            else {
                return httpsAgent;
            }
        };
        return opts;
    }
    checkStatus(status) {
        return status >= 200 && status < 300;
    }
    createResponse(opts, res, data) {
        const headers = {};
        res.headers.forEach((value, key) => {
            headers[key] = value;
        });
        return {
            config: opts,
            data: data,
            headers,
            status: res.status,
            statusText: res.statusText,
            request: {
                responseUrl: res.url,
            },
        };
    }
}
exports.Vetch = Vetch;
//# sourceMappingURL=vetch.js.map